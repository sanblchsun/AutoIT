
На данный момент есть несколько алгоритмов поиска

1. Используется в RecFileListToArray от Melba23. При каждом входе в папку её содержимое добавляется в конец массива и счётчик увеличивается на столько же. Далее следующий шаг цикла начинается с последней папки. Массив не очищается в конце, просто счётчик уменшается, указывая на последний необработанный элемент. Если счётчик будет увеличиваться, то перезапишет старые элементы в конце. А если массив не достаточен для вмещения, то увеличится в 2 раза. Недостаток: требует сортировки, так как каждая папка обрабатывается с конца.


2. Используется в тестовом от AZJIO. При каждом входе в папку в конец массива добавляется дескриптор поиска и каталог и счётчик увеличивается на 1. Далее следующий шаг цикла начинается с поиска файла последнего дескриптора указанного в массиве. Массив не очищается в конце, просто счётчик уменшается, указывая на последний необработанный элемент. Если счётчик будет увеличиваться, то перезапишет старые элементы в конце. В отличии от предыдущего варианта массив задаётся по максимальной глубине вложения - 125 и не требует проверки в дальнейшем, а также результатом является сортированный список как и в последующих функциях. (сортировка не совсем соответствует сортировке в эксплорере)

3. Аналог пункта 2 - вариант от NIKZZZZ. Дескриптор поиска хранится в массиве. Но различие, что данные не возвращаются в список в возвращаемый результат, а делается инициализация старта и последующий вызов файла, так же как и нативная функция.

4. Используется в FileOperations от AZJIO. Рекурсивный вызов. Пока что самый быстрый вариант. При каждом входе во вложенную папку функция вызывает саму себя, открывая новый дескриптор поиска.

5. Вариант с использованием CMD DIR от CreatoR и amel27. Если не использовать регулярное выражение, то нативная маска при захвате *.doc захватывает и *.docx, то есть работает как *.doc*. При использовании маски "*пример.doc" последнее правило не работает, то есть docx игнорируются.



Вариант от therks, можно рассматривать скорее не как разновидность, а как ункальное добавление фишки - встраивание функции обратного вызова. Вариант перекликается способом обработки с вариантом NIKZZZZ. То есть не так чтобы сначала получить файлы, а потом обрабатывать по готовому списку, а сразу получить первый файл и начать его обрабатывать по необходимому алгоритму, в варианте therks это делает функция обратного вызова. Такая возможность особого значения не имеет, так как получение списка происходит значительно быстрее (в десятки раз), по сравнению с последующей обработкой (например 0,04-0,4 сек. для 10000 файлов). К тому же часто необходимо тот же список использовать более одного раза, а значит получить его единожды будет экономичней. Преимущество такого способа может быть, когда получение списка происходит с ошибкой, и необходимо обработать хотя бы часть файлов, чем вообще ничего или предварительный вывод определённого количества файлов.