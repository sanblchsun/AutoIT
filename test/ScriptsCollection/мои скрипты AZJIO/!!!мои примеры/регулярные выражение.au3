
MsgBox(0, "Сообщение", 'только для чтения внутри скрипта')
Exit

;Заготовки регулярных выражений

;=====================================================================================
;REG-файлы
;Удаление пустых секций в ini,reg-файлах два варианта
$initext=StringTrimRight (StringRegExpReplace($initext & "[","\[[^\]]*\]\s*(?=\[)",""),1)
$initext=StringRegExpReplace($initext,'(\[.*\])(?=(\s+\[.*|\s+$|$))','')

;обрамление спец-символов в образце поиска, например путь или ветка реестра
; замена C:\inst\new на C:\\inst\\new или HKCR\CLSID\{000-25B} на HKCR\CLSID\\\{000-25B\}
$regstring=StringRegExpReplace($regstring, '[][{}()*+?.\\^$|=<>#]', '\\$0')

;для удаления из рег-файлов веток начинающихся с указанных символов, вместе с параметрами.
$regstring=StringRegExpReplace($regstring, '(?s)\[(HKEY_USERS|HKEY_CURRENT_CONFIG|HKEY_LOCAL_MACHINE\\HARDWARE|HKEY_LOCAL_MACHINE\\SAM|HKEY_LOCAL_MACHINE\\SECURITY).*?([^\[]*)', '')

;удаление пустых строк, т.е. удаляется последовательный двойной переход на следующую строку.
$initext=StringRegExpReplace($initext,'\n\r?\n\r?','')

;=====================================================================================
;Операции с файлами и папками
;Выделить группы в элементы массива - путь и имя файла, например из C:\inst\new\file.txt
$aPath=StringRegExp($Path,'(^.*)\\(.*)$',3)
$aPath[0]=; путь без имени файла, например C:\inst\new
$aPath[1]=; имя файла, например file.txt

; по предыдущей аналогии разбиваем на три группы путь, имя, расширение
$aPath=StringRegExp($Path,'(^.*)\\(.*)\.(.*)$',3)
$aPath[0]=; путь без имени файла, например C:\inst\new
$aPath[1]=; имя файла, например file
$aPath[2]=; расширение, например txt

;Выделить группы в элементы массива - путь\имя файла и расширение
$aPath=StringRegExp($Path,'(^.*)\.(.*)$',3)
$aPath[0]=; путь и имя файла без расширения, например C:\inst\new\file
$aPath[1]=; расширение, например txt

; Получить  элемент без массива, например имя файла или путь или расширение в пеерменную. Если заменить на \1 то это значит заменить на первую группу из найденного, \2 - вторую группу и т.д.
$Path=StringRegExpReplace($Path, '(^.*)\\(.*)$', '\1') ; получаем путь в переменную
$filename=StringRegExpReplace($Path, '(^.*)\\(.*)$', '\2') ; получаем имя файла с расширением в переменную
$Path=StringRegExpReplace($Path, '(^.*)\\(.*)\.(.*)$', '\1') ; получаем путь в переменную
$filename=StringRegExpReplace($Path, '(^.*)\\(.*)\.(.*)$', '\2') ; получаем имя файла без расширения в переменную
$filetype=StringRegExpReplace($Path, '(^.*)\\(.*)\.(.*)$', '\3') ; получаем расширение в переменную

; Получить  элемент без массива, например имя файла или путь или расширение в пеерменную, но с исключением группы из поиска - ?:
; Символ ?: исключает группу из шаблона, то есть возвращается только одна группа
$Path=StringRegExpReplace($Path, '(?:.*)\\(.*)$', '\1') ; получаем имя файла с расширением в переменную
$Path=StringRegExpReplace($Path, '(.*)\\(?:.*)$', '\1') ; получаем путь в переменную


$Path=StringRegExpReplace($Path, '.*\.(\S+)', '\1') ; получаем расширение в переменную

$Path=StringRegExp($Path, '(?i)(.+\.exe)\s*?(.+)?',3) ; путь + ключи

;=====================================================================================
; ini - файлы
; регулярное выражение для вытаскивания секций SetValue в массив
$aSetValue = StringRegExp($inffile, '(?s)\[SetValue\]([^\[]*)', 3)
; и далее обработкой этих секций регулярным для разделения строки на четыре группы параметров - (имя файла|секция|параметр|значение)
$aValue= StringRegExp($Value, '"(.*)", ?"(.*)", ?"(.*)", ?"(.*)"', 3)

$aISO = StringRegExpReplace($ini2, "(?s).*\[iso\]\r?\n(.*?)(?:\r?\n\[.*)", "\1") ; регулярное выражение для вытаскивания содержимого секции [iso] в массив
$filetext = StringRegExpReplace($filetext, "(?s).*\[Wim\]\r\n(.*?)(?:\r\n\[.*)", "\1"); регулярное выражение для вытаскивания содержимого секции [Wim] в массив

;Выражение для выделения в группы пути из строк типа: Mount Path ....:[B:\wim_DupeLocater]
$aPathwim = StringRegExp($wiminfo, "(?i)Mount Path \.*:\[(.*)]", 3)
;(?i)mount\spath\s\.*:\[([^]]+)\]

;Найти текст EB1A но только тот, после которого идёт E9080039. Удобно при замене сделать особую избирательность поиска.
$Binary  = StringRegExpReplace($Binary, "EB1A(?=E9080039)", "7403")

; поиск текста в тегах <NAME>текст</NAME>
$labelwim0 = StringRegExpReplace($wiminfo, "(?s).*<NAME>(.*)</NAME>.*", "\1")



