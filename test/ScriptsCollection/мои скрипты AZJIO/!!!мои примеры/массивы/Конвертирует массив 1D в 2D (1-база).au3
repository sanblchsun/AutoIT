#include <Array.au3>

; —оздание тестового массива
Local $1D[1000] = [999] ; массив на 1000 элементов, в первом элементе, индекс которого [0], находитс€ число элементов

For $i = 1 To 999
	$1D[$i] = Random(1, 10, 1)
Next
_ArrayDisplay($1D, 'ќдномерный массив')

; ѕреобразование
Local $2D[ $1D[0] + 1 ][2] = [[ $1D[0] ]] ; в качестве размера используем число элементов 1D-массива и указываем нулевой элемент
For $i = 1 To $1D[0]
	$2D[$i][0] = $1D[$i] ; переписываем первую колонку как есть
	$2D[$i][1] = $1D[$i] * 2 ; заполн€ем вторую колонку
Next
$1D = 0 ; обнуление массива если он больше не нужен
_ArrayDisplay($2D, 'ƒвумерный массив')

; Ёто может пригодитс€ в следующих случа€х: например функци€ возвращает список файлов в виде одномерного массива, но хотелось бы иметь двумерный массив с колонками например "–азмер файла", "ƒата файла", јтрибуты файла", " онтрольна€ сумма файла". ѕри этом число колонок можно сделать сколько угодно.

;  ак вариант, если массив слишком большой и переписывание колонки €вл€етс€ затратным, то вполне можно создать параллельный одномерный или двумерный массив, в котором данные любого индекса соответствуют данным того же индекса в другом массиве. “о есть фактически это не вли€ет на обработку массива, кроме случа€, что использовать многие  функции UDF _Array... станет невозможным, например сортировка не может применитьс€ к двум массивам.